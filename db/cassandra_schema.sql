DROP KEYSPACE IF EXISTS dishes_keyspace;

-- Settings for Replication. Data will be replicated across node in the cluster
-- Class simple used since we are only running a one node cluster
--  durable writes: if false, will increase speed of writes, but also increases data loss
CREATE KEYSPACE dishes_keyspace WITH REPLICATION = {'class': 'SimpleStrategy', 'replication_factor': '1'} AND durable_writes = 'true';

USE dishes_keyspace

-- -----------Query First Approach(Tables should reflect the Queries we are trying to make)----------------

-- Q1: Find info of a restaurant by restaurant id
--  Table Name: Restaurant By Id
-- One to One relationship. Each restaurany has one column value representing a piece of information data
CREATE TABLE restaurant_by_id (
  id: int PRIMARY KEY,
  name varchar(30),
  phone varchar(11),
  email varchar(30),
  city varchar(30),
  state varchar(4),
  zip varchar(15)
);

-- Q2: Find all dishes by restaurant ID
-- Table Name: Dishes By Restaurant Id
-- One to many relationship. each restaurant can have many popular dishes
CREATE TABLE dishes_by_restaurant_id (
  id int PRIMARY KEY,
  restaurant_id int,
  name varchar(30) NOT NULL,
  description varchar(100),
  photo varchar(200)
);

-- Q3: Find dishes by cateogry
-- Table Name: Dishes By Category
-- One to one relationship. each dish only has only has one category
-- Composite Key:
    -- Partition Key: category. The data will be stored on the node category.
    -- Clustering Column: the data for each node will be sorted by id
CREATE TABLE dishes_by_category (
  id int,
  restaurant_id int,
  category varchar(50),
  name varchar(30) NOT NULL,
  description varchar(100),
  photo varchar(200),
  PRIMARY KEY(category, id)
);

-- Q4: Lookup user info by user id
-- Table Name: User By Id
-- One to one relationship. Each user has one one column value for each piece of data representing information of the restraurant
CREATE TABLE user_by_id (
  id int PRIMARY KEY,
  username varchar(30),
  avatar varchar(150)
  vip_status BOOLEAN
);

-- Q5: Get users by vip_status
-- Table Name: user by vip status
-- Composite Key:
    -- Partition Key: vip_status, the data will be stored on unique nodes either True or False
    -- Clustering Columns: username and id. The data at each node will be sorted by username then id
CREATE TABLE user_by_vip_status (
  id INT,
  username VARCHAR(30),
  avatar VARCHAR(150),
  vip_status BOOLEAN,
  PRIMARY KEY (vip_status, (username, id))
);

-- Q5: Find a review by review id
-- Table Name: Review By Id
-- One to One relationship, each review id will only have one review short paragraph associated with it
CREATE TABLE review_by_id (
  id int PRIMARY KEY,
  user_id INT,
  dish_id: int,
  review text,
  date DATE,
  stars SMALLINT,
);

-- Q6: Find reviews by stars
-- Table name: review by stars
-- Composite Key:
    -- Partition Key: stars. the data will be stored on appropriate nodes representing if the stars rating is 1, 2, 3, 4, or 5
    -- Clustering Columns: the data at each node will be sorted by review id
CREATE TABLE reviews_by_stars (
  id INT,
  user_id INT,
  dish_id: INT,
  review: TEXT,
  date DATE,
  stars SMALLINT,
  PRIMARY KEY (stars, id)
) ;



-- Every row has a Primary or Composite key which is made up for the Partition Key and  number of clustering columns user for sorting data

-- Partition Key goes through a hash function which generates a token(64 bit int: -2^63- 2^63 - 1) specific to the partition key
-- new data with the same partition key will have the same token generated by the hash function, which groups on the same node